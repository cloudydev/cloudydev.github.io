---
layout: post
title: chipmunk 7 代码实现
---

h1. 工程

真正有用的代码在 include 和 src 文件夹下面，代码量不到1w行:

<pre class="table">
[roc : Chipmunk2D]$: cloc include/ src/
      55 text files.
      55 unique files.
       0 files ignored.

http://cloc.sourceforge.net v 1.60  T=0.37 s (148.6 files/s, 34996.2 lines/s)
------------------------------------------------------------------------------
Language                files           blank         comment           code
------------------------------------------------------------------------------
C                       28              1654          991               6469
C/C++ Header            26              698           1246              1844
CMake                   1               4             7                 37
------------------------------------------------------------------------------
SUM:                    55              2356          2244              8350
------------------------------------------------------------------------------
</pre>

用Xcode打开，源代码根据用途分成Basics, Collision, Constraints, Space四个模块:

<div class="figure">
<img src="\data\img_chipmunk_7_xcode.png">
</div>
p.  


h2. Basics

Basics下面是chipmunk里面用到的基本数据结构，包括两种存储容器：数组 (cpArray )和哈希表 (cpHashSet)，向量 (cpVec), AABB包围体 (cpBB), 和变换矩阵(cpTransform)。

其中变换矩阵是由一个旋转缩放矩阵 \( \begin{pmatrix} a & b \\ c & d \end{pmatrix} \) ，另外加上一个位移分量 \( \begin{pmatrix} tx \\ ty \end{pmatrix} \) 

{% highlight  C %}
#if CP_USE_CGTYPES
    typedef CGAffineTransform cpTransform;
#else
    /// Column major affine transform.
    typedef struct cpTransform {
    	cpFloat a, b, c, d, tx, ty;
    } cpTransform;
#endif
{% endhighlight %}

p. 

h2. Body & Shape

cpBody代表一个具体的物体，实现很简单，chipmunk 7 定义了三种物体类型: 

{% highlight  C %}
typedef enum cpBodyType {
    CP_BODY_TYPE_DYNAMIC,
    CP_BODY_TYPE_KINEMATIC,
    CP_BODY_TYPE_STATIC,
} cpBodyType;
{% endhighlight %}

**static**: 质量无穷大，位置固定，速度为 0 的物体，而且不会因为外力作用或者碰撞而改变运动状态。
**dynamic**: 有一定质量的物体，外力施加到上面或发生碰撞时会改变运动状态。
**kinematic**: 同static物体类似，不响应外力作用和碰慌效果，但是有一定质量，自身可以有速度的物体。

Shape用来定义一个物体的具体形状，也是用来做碰撞检测的基本单元，chipmunk 7 定义了三种形状类型：

{% highlight  C %}
typedef enum cpShapeType{
    CP_CIRCLE_SHAPE,
    CP_SEGMENT_SHAPE,
    CP_POLY_SHAPE,
    CP_NUM_SHAPES
} cpShapeType;
{% endhighlight %}

p.  

h2. Collision

两个具体形状之间的碰撞检测函数定义成如下形式：

{% highlight  C %}
typedef void (*CollisionFunc)(const cpShape *a,
                              const cpShape *b,
                              struct cpCollisionInfo *info);
{% endhighlight %}

不同形状之间的碰撞函数存在一个函数指针数组里面，并按照两个形状的类型枚举值进行寻址 (这里是把枚举小的放到 \(type_a\) ):
$$ index = type_a + type_b \cdot \text{CP_NUM_SHAPES};$$

<pre class="table">
  -------------------------------------------------------------------------
  | type             | CP_CIRCLE_SHAPE | CP_SEGMENT_SHAPE | CP_POLY_SHAPE |
  -------------------------------------------------------------------------
  | CP_CIRCLE_SHAPE  | CircleToCircle  | x                | x             |
  | CP_SEGMENT_SHAPE | CircleToSegment | SegmentToSegment | x             |
  | CP_POLY_SHAPE    | CircleToPoly    | SegmentToPoly    | PolyToPoly    |
  -------------------------------------------------------------------------
</pre>

p.  

h2. Time step

time step是最重要的部分，实现在Space/cpSpaceStep.c里：

{% highlight  C %}
void
cpSpaceStep(cpSpace *space, cpFloat dt)
{
    /* 1 初始化 */
    /* 2 位置积分 */
    /* 3 碰撞检测 */
    /* 4 休眠检测 */
    /* 5 约束求解-常量部分 */
    /* 6 速度积分 */
    /* 7 叠加缓存冲量 */
    /* 8 约束求解-迭代部分 */
}
{% endhighlight %}

p.  

h3. 1. 初始化

p. 

{% highlight  C %}
if(dt == 0.0f) return;

/* 初始化相关变量：*/

/* 更新碰撞对状态 */
for(int i=0; i<arbiters->num; i++){
    cpArbiter *arb = (cpArbiter *)arbiters->arr[i];
    arb->state = CP_ARBITER_STATE_NORMAL;
            
    /* 删除无效的碰撞对 */
    if(!cpBodyIsSleeping(arb->body_a) && !cpBodyIsSleeping(arb->body_b)){
        cpArbiterUnthread(arb);
    }
}
arbiters->num = 0;

/* ... */
{% endhighlight %}

p.  

h3. 2. 位置 & 速度积分

物体的位置和速度的积分逻辑被封装成了对应的函数，作为Body结构的成员之一：

{% highlight  C %}
struct cpBody {
    // Integration functions
    cpBodyVelocityFunc velocity_func;
    cpBodyPositionFunc position_func;
	
    /* other menbers */
}
{% endhighlight %}

chipmunk对这部分的积分用了最简单的["欧拉积分":http://en.wikipedia.org/wiki/Euler_method] ，对位置的积分放到了速度积分的前面(?)。

h3. 3. 碰撞检测

TODO

h3. 4. 休眠检测

物体睡眠相关的实现在cpSpaceComponent.c里面，在cpSpace结构体里定义了两个阀值:

{% highlight  C %}
struct cpSpace {
    /* other menbers */
	
    cpVect gravity;
    cpFloat damping;
	
    cpFloat idleSpeedThreshold;
    cpFloat sleepTimeThreshold;
}
{% endhighlight %}
p.  

**idleSpeedThreshold**: 速度阀值，当物体的速度小于这个值时，可以近似的认为这个物体是静止的。
**sleepTimeTreshold**: 时间阀值，当物体保持静止的时间超过这个值时，我们认为这个物体是处于静止状态。

p.  

{% highlight  C %}
void
cpSpaceStep(cpSpace *space, cpFloat dt)
{
    /* ... */
    
    /* 4 睡眠检测: */
    cpSpaceProcessComponents(space, dt);
    {
        cpBool sleep = (space->sleepTimeThreshold != INFINITY);
        cpArray *bodies = space->dynamicBodies;
        
        /* 4.1 更新静止时间 */	
	/* 4.2 唤醒受到干扰的物体 */
        /* 4.3 创建contact graph */
        /* 4.4 休眠满足条件的物体 */
    }
    
    /* ... */
}
{% endhighlight %}

p. 

* **静止时间**

p. 

chipmunk对于静止状态的判定是根据物体动能的大小，根据 cpSpace 里定义的速度阀值，可以计算出每个物体的最小动能，当物体的动能低于这个最小值时，累积它的静止时间：

p. 

{% highlight  C %}
if(sleep){
    /* 4.1 更新静止时间 */
    cpFloat dv = space->idleSpeedThreshold;
    cpFloat dvsq = (dv ? dv*dv : cpvlengthsq(space->gravity)*dt*dt);
		
    for(int i=0; i<bodies->num; i++){
        cpBody *body = (cpBody*)bodies->arr[i];
			
	if(cpBodyGetType(body) != CP_BODY_TYPE_DYNAMIC) continue;
			
	cpFloat keThreshold = (dvsq ? body->m*dvsq : 0.0f);
	ody->sleeping.idleTime = (cpBodyKineticEnergy(body) > keThreshold ?
                                      0.0f : body->sleeping.idleTime + dt);
    }
}
{% endhighlight %}

p.  

* **contact graph**

考虑到物体之间的碰撞作用，当有多个物体参与了碰撞时，即使其中一个物体达到了休眠的条件，我们也无法简单的就将这个物体休眠掉。比如下图这种情况：

A 与 B 发生碰撞，B 和 C 之间有接触碰撞，虽然 C 物体已经满足休眠条件，但是 A 与 B 碰撞之后必定会改变 C 物体的状态，因此 C 物体在下一帧时会重新被唤醒，这种情况下的休眠就没有什么意义了。

因此，一个动态物体进入休眠状态需要两个条件：

p(. 1. 这个物体要处于静止状态
2. 与这个物体有 %{color:RED}接触关系% (包括碰撞接触和约束关系) 的物体都处于静止状态。

更进一步说，当满足上述条件时，有接触关系的一族物体都可以进入休眠状态。我们把物体当作节点，接触关系当作边，很容易用一张图来表示物体之间的接触关系，这个就是 contact graph。

<div class="figure">
<img src="/data/contact_graph.png">
</div>

chipmunk 7 用邻接表来表示这张 contact graph: cpBody 的结构体里定义了一个 sleeping 结构体来存储接触关系，每个物体的实例里面都缓存了一份与这个物体有关的碰撞对列表 **arbiterList** 和约束列表 **constraintList**

{% highlight  C %}
struct cpBody {
    /* other members */
    
    cpArbiter *arbiterList;
    cpConstraint *constraintList;
      
    struct {
        cpBody *root;
	cpBody *next;
    	cpFloat idleTime;
    } sleeping;
};
{% endhighlight %}

p.  
创建contact graph的过程很简单，只需要 DFS 遍历 arbiterList 和 constrainList 即可:

{% highlight  C %}
for(int i=0; i<bodies->num;){
    cpBody *body = (cpBody*)bodies->arr[i];
    
    /* 4.3 创建contact graph */
    if(ComponentRoot(body) == NULL){
        /** 以body为根节点，DFS 生成 contact graph: **/
        FloodFillComponent(body, body);
       
        /** 遍历这张 contact graph，判断是否满足休眠条件:**/
        if(!ComponentActive(body, space->sleepTimeThreshold)){
            cpArrayPush(space->sleepingComponents, body);

            /** 4.4 休眠满足条件的物体: **/
            CP_BODY_FOREACH_COMPONENT(body, other) 
                cpSpaceDeactivateBody(space, other);
            
            continue;
        }
    }
    
    i++;
    
    body->sleeping.root = NULL;
    body->sleeping.next = NULL;
}
{% endhighlight %}


p.  

* **休眠**

p. 让一个动态物体进入休眠状态是暂时把这个物体当作"静态物体"来看待，因为静态物体只会被动的参与碰撞，这样就省掉了这个物体与其他物体碰撞检测的 CPU 运算。

{% highlight  C %}
static void
cpSpaceDeactivateBody(cpSpace *space, cpBody *body)
{
    /* 把物体从 space 的动态物体列表中移除 */
    cpArrayDeleteObj(space->dynamicBodies, body);
    
    /* 把物体所包含的所有形状，从动态加速体里移除并添加到静态加速体中 */
    CP_BODY_FOREACH_SHAPE(body, shape){
        cpSpatialIndexRemove(space->dynamicShapes, shape, shape->hashid);
        cpSpatialIndexInsert(space->staticShapes, shape, shape->hashid);
    }
    
    /** 把休眠物体之间的碰撞对和约束从space的缓存中删除 **/
    CP_BODY_FOREACH_ARBITER(body, arb){
        /* implment */
    }
            
    CP_BODY_FOREACH_CONSTRAINT(body, constraint){
        /* implment */
    }
}
{% endhighlight %}

p.  

* **唤醒**

p.  

不幸的是，物体显然不会一直的休眠下去，总会有一些外界的干扰会把它从休眠状态唤醒，这里的干扰包括：

p(. 1. 有其他正在活动的物体发生了碰撞
2. 与 **kinematic** 物体有接触
3. 游戏逻辑强制唤醒一个物体

{% highlight  C %}

/* 4.2 唤醒受到干扰的物体 */
cpArray *arbiters = space->arbiters;
for(int i=0, count=arbiters->num; i<count; i++){
    if (sleep) {
       /* 唤醒与kinematic物体碰撞的物体 */
    }
}

if(sleep){
    cpArray *constraints = space->constraints;
    for(int i=0; i<constraints->num; i++){
       /* 唤醒与kinematic物体有约束关系的物体 */
    }

    /* 4.3 创建contact graph */
    /* 4.4 休眠满足条件的物体 */
}
{% endhighlight %}

p.  

唤醒一个物体的过程和休眠的过程类似，只是把相关的操作反向执行一次：

{% highlight  C %}
void
cpSpaceActivateBody(cpSpace *space, cpBody *body)
{
    /* ... */

    /* 把物体添加到 space 的动态物体列表中 */
    cpArrayPush(space->dynamicBodies, body);

    /* 把物体所包含的所有形状，从静态加速体里移除并添加到动态加速体中 */
    CP_BODY_FOREACH_SHAPE(body, shape){
            cpSpatialIndexRemove(space->staticShapes, shape, shape->hashid);
            cpSpatialIndexInsert(space->dynamicShapes, shape, shape->hashid);
    }
    
    /** 把休眠物体之间的碰撞对和约束添加到space的缓存中 **/
    CP_BODY_FOREACH_ARBITER(body, arb){
        /* implement */
    }
    
    CP_BODY_FOREACH_CONSTRAINT(body, constraint){
        /* implement */
    }
}
{% endhighlight %}

p.  

h3. 5. 约束求解

约束求解的部分被分成了两个步骤, 常量计算部分和迭代计算部分，两个步骤之间插入了一步速度积分的过程

{% highlight  C %}
void
cpSpaceStep(cpSpace *space, cpFloat dt)
{
    cpSpaceLock(space); {
    /* 5 约束求解-常量部分 */
        /* 5.1 过滤无效碰撞体 */
        cpHashSetFilter(space->cachedArbiters, 
          (cpHashSetFilterFunc)cpSpaceArbiterSetFilter,
          space);
  
        /* 5.2 求解碰撞方程，常量部分 */
        cpFloat slop = space->collisionSlop;
	cpFloat biasCoef = 1.0f - cpfpow(space->collisionBias, dt);
	for(int i=0; i<arbiters->num; i++){
            cpArbiterPreStep((cpArbiter *)arbiters->arr[i], dt, slop, biasCoef);
      	}

        /* 5.3 求解自定义约束方程，常量部分 */
        for(int i=0; i<constraints->num; i++){
	    cpConstraint *constraint = (cpConstraint *)constraints->arr[i];
            /* ... */
	    constraint->klass->preStep(constraint, dt);
      	}
    /* 6 速度积分 */
    /* 7 施加缓存冲量 */ 
    /* 8 约束求解-迭代部分 */
        for(int i=0; i<space->iterations; i++){
            /* 8.1 求解碰撞方程，迭代部分*/
	    for(int j=0; j<arbiters->num; j++){
		cpArbiterApplyImpulse((cpArbiter *)arbiters->arr[j]);
	    }
	    
            /* 8.2 求解自定义约束方程,迭代部分 */
	    for(int j=0; j<constraints->num; j++){
		cpConstraint *constraint = (cpConstraint *)constraints->arr[j];
		constraint->klass->applyImpulse(constraint, dt);
            }
	}
    } cpSpaceUnlock(space, cpTrue);
}
{% endhighlight %}

p.  

* 过滤无效碰撞体

p. 

一个碰撞体，如果一个碰撞对的碰撞持续时间超过了预定义的阀值，这个碰撞对就被定义为失效，不需要进行处理：

{% highlight  C %}
cpBool
cpSpaceArbiterSetFilter(cpArbiter *arb, cpSpace *space)
{       
    /* 统计碰撞体的持续时间: */
    cpTimestamp ticks = space->stamp - arb->stamp;
    cpBody *a = arb->body_a, *b = arb->body_b;
    
    /* ... */

    /* 持续时间超过阀值，碰撞对已经失效 */
    if(ticks >= space->collisionPersistence){
        /* 回收这个碰撞对的内存 */
        arb->contacts = NULL;
	arb->count = 0;
		
	cpArrayPush(space->pooledArbiters, arb);
	return cpFalse;
    }
    return cpTrue;
}
{% endhighlight %}

p.  

* 碰撞方程-常量部分
** con->nMass 代表1_4中的分母部分，对于迭代求解的算法中，这部分是常量，因此单独把这一部分的计算放到了前面
** con->bounce 是公式1_4中的 \( e \cdot \Delta \vec{u}_{(t, \vec{n})} \)

p.  

{% highlight  C %}
void
cpArbiterPreStep(cpArbiter *arb, cpFloat dt, cpFloat slop, cpFloat bias)
{
    cpBody *a = arb->body_a;
    cpBody *b = arb->body_b;
    cpVect n = arb->n;
    cpVect body_delta = cpvsub(b->p, a->p);
	
    for(int i=0; i<arb->count; i++){
	struct cpContact *con = &arb->contacts[i];
        /* 计算mMass, tMass, bias, jBias, bounce */
    }
}
{% endhighlight %}

p. 


* 碰撞方程-迭代部分

p.  

作者把碰撞和自定义约束的求解放到了一个循环体內，在**cpArbiterApplyImpulse** 中计算公式 **1_4** 中的冲量 \(\vec{J}\)，作用到物体上立即改变速度状态：

p. 

{% highlight  C %}
void
cpArbiterApplyImpulse(cpArbiter *arb)
{
    /* setup variable ... */
  
    for(int i=0; i<arb->count; i++){
        struct cpContact *con = &arb->contacts[i];
        /* 计算碰撞方向上的冲量jn, 摩擦力方向的冲量jt，Bias冲量jBias*/
        /* 更新con->jnAcc, con->jtAcc, con->jBias*/
        /* 将冲量作用到物体上*/
        apply_bias_impulses( /* params */ );
        apply_impulses( /* params */ );
    }
}
{% endhighlight %}

* 施加缓存的冲量

碰撞的持续时间
TODO

$$
\vec{J} = \int \vec{F} dt
$$


<div class="figure">
<img src="/data/impluse.png">
</div>



